// #include <NanoRp2040MicTest_inferencing.h>
// #include <PDM.h>

#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "myIot_RGB_LED_ctrl"
  https://create.arduino.cc/cloud/things/249e978c-5f43-4da1-837f-05840ec66bc1

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float fHumidity;
  float fLightBrightness;
  float fTemperature;
  CloudColoredLight setRGBColor;
  int intSetMode;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include <ArduinoBLE.h>
#include <WiFiNINA.h>
#include <Arduino_LSM6DSOX.h>
#include <BH1750.h>
#include <DHT.h>
#include <cmath>
#include <NeoPixelConnect.h>
#include <SPI.h>
#include "thingProperties.h"
#include <Wire.h>
#include <arduino-timer.h>

// 원형 LED
#define NEOPIXELS_CONTROL_PIN 20
#define NUM_NEOPIXELS 12
// LED
#define MIC_REC_PIXEL_CONTROL_PIN 19
#define MIC_REC_NUM_OF_PIXEL 3
// 온습도센서
#define DHTPIN 3
#define DHTTYPE DHT22
// BLE
#define DEBUG_MODE_ENABLE 1
#define BT_AT_COMMAND_ENABLE 0
#define BT_RENAME_ENABLE 0
#define BT_BAUDRATE_CHANGE_ENABLE 0

// 모드선택
#define IoTMODE_WIFI 1
#define IoTMODE_BLE 2

#define IoTMODE_CHANGE_DEACTIVATE_WIFI 3
#define IoTMODE_CHANGE_ACTIVATE_WIFI 4

#define IoTMODE_CHANGE_DEACTIVATE_BLE 5
#define IoTMODE_CHANGE_ACTIVATE_BLE 6

#define AI_MODE_PREPARE 7
#define AI_MODE_RUN_SPEECH_CONTROL 8
#define AI_MODE_END_PROCESS 9

#define LED_MODE_WAIT_BLE_CONN 10
#define LED_MODE_WAIT_IOT_CLOUD_CONN 20
#define EIDSP_QUANTIZE_FILTERBANK 0


BLEService myService("0000ffe0-0000-1000-8000-00805f9b34fb");
BLECharacteristic myCharacteristic("0000ffe1-0000-1000-8000-00805f9b34fb", BLERead | BLEWrite | BLEWriteWithoutResponse | BLENotify, 32);


unsigned long sensingInterval = 2000;
unsigned long sensingPreviousMillis = 0;

// 동적LED 변수
unsigned long dynamicLedCtrlInterval = 100;
unsigned long dynamicLedCtrlPreviousMillis = 0;

String strMsgPacket, strTempMsgBuf;
unsigned char seqSetLedModeForWaitingBleConnection;
unsigned char seqSetLedModeForwaitingIoTCloudConnection;

unsigned char cmdMode, valueSetBrightness = 150;
uint8_t redColor, greenColor, blueColor;
unsigned char getRedColor = 0, getGreenColor = 0, getBlueColor = 0;
bool flgModeColorControl, flgModeEffectA, flgModeEffectB, flgModeEffectC, flgBLE_CONN_Check = 0;
bool flgModeDynamicEffectA = 0, flgModeDynamicEffectB = 0;
bool flgEmotionalModeEnable = 0, flgAutoBrightnessMode = 0, flgMachineLearningKeyWordSpeechControlMode = 0;

bool myCloudSwitchStatus = 0;
//ble
unsigned char deltaHumidity = 0;
unsigned long pixelsInterval = 500;  // the time we need to wait
unsigned long rainbowPreviousMillis = 0;
unsigned long rainbowCyclesPreviousMillis = 0;
unsigned long setTimerIntervalForReadSensorValue = 1000;
unsigned long readSensorValuePreviousMillis = 0;
int rainbowCycles = 0;
int rainbowCycleCycles = 0;
int numPixel = 0, seqColorWipeHandlerFlowCtrl = 0;
uint16_t currentPixel = 0;  // what pixel are we operating on
bool ble_connected = 0;
float hue, saturation, value;
unsigned char setDeviceFunctionMode = 0;
int potValue = 0;
float Volt = 0;
unsigned long taskInterval = 1000;
unsigned long taskPreviousMillis = 0;
unsigned char setIoT_Mode = IoTMODE_WIFI;
unsigned char cntBLE_Connection = 0;

typedef struct {
  int16_t *buffer;
  uint8_t buf_ready;
  uint32_t buf_count;
  uint32_t n_samples;
} inference_t;

static inference_t inference;
static signed short sampleBuffer[2048];
static bool debug_nn = false;  // Set this to true to see e.g. features generated from the raw signal
static volatile bool record_ready = false;

bool flgRestartMicrophone = 0;
bool flgKeyDetectedRed = 0, flgKeyDetectedGreen = 0, flgKeyDetectedBlue = 0;

bool flagWiFiOpModeInfoDisplay = 0, flagBleOpModeInfoDisyplay = 0, flagSpeechOpModeInfoDisplay = 0;
/*
enum BLEProperty {
  BLEBroadcast            = 0x01,
  BLERead                 = 0x02,
  BLEWriteWithoutResponse = 0x04,
  BLEWrite                = 0x08,
  BLENotify               = 0x10,
  BLEIndicate             = 0x20,
  BLEAuthSignedWrite      = 1 << 6,
  BLEExtProp              = 1 << 7,
};
*/

// 원형LED
NeoPixelConnect myLEDstrip(NEOPIXELS_CONTROL_PIN, NUM_NEOPIXELS, pio0, 0);
NeoPixelConnect myLEDstripMIC(MIC_REC_PIXEL_CONTROL_PIN, MIC_REC_NUM_OF_PIXEL, pio1, 1);

// 온습도 센서
DHT myDHT(DHTPIN, DHTTYPE);
void sendHSV_ColorDataToCloud(void);

// 조도센서
BH1750 lightMeter;

Timer<1, micros> timer;


void setup() {
  // Initialize serial and wait for port to open:

  Serial.begin(9600);
  delay(100);
  myDHT.begin();
  delay(100);
  Wire.begin();
  delay(100);
  // BH1750 센서 설정
  if (lightMeter.begin(BH1750::CONTINUOUS_HIGH_RES_MODE)) {
    Serial.println(F("BH1750 Advanced begin"));
  } else {
    Serial.println(F("Error initialising BH1750"));
  }

  timer.every(200000, mySensorDataAcquisitionFunction);

  myArduinoIotCloudInitHandler();
  redColor = 100;
  greenColor = 100;
  blueColor = 100;

  myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true);
  myLEDstripMIC.neoPixelFill(255, 0, 0, true);
  delay(1000);
  myLEDstripMIC.neoPixelFill(0, 255, 0, true);
  delay(1000);
  myLEDstripMIC.neoPixelFill(0, 0, 255, true);
  delay(1000);
  myLEDstripMIC.neoPixelFill(redColor / 2, greenColor / 2, blueColor / 2, true);


  // onIntSetModeChange();
}


void loop() {
  timer.tick();
  myIoT_DeviceModeChangeHandler();
  appLedStripControlHandler();
}

void myIoT_DeviceModeChangeHandler(void) {
  switch (setIoT_Mode) {

    case IoTMODE_WIFI:
      ArduinoCloud.update();
      break;

    case IoTMODE_BLE:
      BLE.poll();
      break;

    case IoTMODE_CHANGE_DEACTIVATE_BLE:
      BLE.stopAdvertise();
      delay(100);
      setIoT_Mode = IoTMODE_WIFI;
      break;

    case IoTMODE_CHANGE_ACTIVATE_BLE:
      myFuncActivateBLE();
      setIoT_Mode = IoTMODE_BLE;
      break;

    case AI_MODE_PREPARE:
      // myAiMlSpeechControlInit();
      setIoT_Mode = AI_MODE_RUN_SPEECH_CONTROL;
      break;

    case AI_MODE_RUN_SPEECH_CONTROL:
      // if (flgMachineLearningKeyWordSpeechControlMode) myMlFuncSpeechControl();
      break;

    case AI_MODE_END_PROCESS:
      // microphone_inference_end();
      flgMachineLearningKeyWordSpeechControlMode = 0;

      intSetMode = 0;
      ArduinoCloud.update();
      setIoT_Mode = IoTMODE_WIFI;
      break;

    default: break;
  }
}

void myFuncActivateBLE(void) {
  intSetMode = 0;
  ArduinoCloud.update();
  delay(500);
  if (!cntBLE_Connection) {
    if (!BLE.begin()) {
#if (DEBUG_MODE_ENABLE)
      Serial.println("starting BLE failed!");
#endif
    } else {
#if (DEBUG_MODE_ENABLE)
      Serial.println("starting BLE success!");
#endif
      cntBLE_Connection = 1;
    }
  } else {
    BLE.disconnect();
    delay(100);
    BLE.end();
    delay(100);
    BLE.begin();
    delay(100);
  }
  BLE.setLocalName("superBLE");
  BLE.setDeviceName("superBLE");
  BLE.setAdvertisedService(myService);
  myService.addCharacteristic(myCharacteristic);
  BLE.addService(myService);
  BLE.setEventHandler(BLEConnected, bleConnectHandler);
  BLE.setEventHandler(BLEDisconnected, bleDisconnectHandler);
  myCharacteristic.setEventHandler(BLEWritten, writtenEventCharacteristic);
  BLE.advertise();
#if (DEBUG_MODE_ENABLE)
  Serial.println("Bluetooth device active, waiting for Central Device Connections...");
#endif
}

// 음성감지 관련
// void myAiMlSpeechControlInit(void) {
// #if (DEBUG_MODE_ENABLE)
//   Serial.println("Edge Impulse Inferencing Demo");
//   delay(500);
//   ei_printf("Inferencing settings:\n");
//   ei_printf("\tInterval: ");
//   ei_printf_float((float)EI_CLASSIFIER_INTERVAL_MS);
//   ei_printf(" ms.\n");
//   ei_printf("\tFrame size: %d\n", EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE);
//   ei_printf("\tSample length: %d ms.\n", EI_CLASSIFIER_RAW_SAMPLE_COUNT / 16);
//   ei_printf("\tNo. of classes: %d\n", sizeof(ei_classifier_inferencing_categories) / sizeof(ei_classifier_inferencing_categories[0]));
// #endif
//   if (microphone_inference_start(EI_CLASSIFIER_RAW_SAMPLE_COUNT) == false) {
//     ei_printf("ERR: Could not allocate audio buffer (size %d), this could be due to the window length of your model\r\n", EI_CLASSIFIER_RAW_SAMPLE_COUNT);
//     return;
//   }
// }

// void myMlFuncSpeechControl(void) {
//   myLEDstripMIC.neoPixelFill(0, 0, 50, true);

//   ei_printf("Starting inferencing in 2 seconds...\n");

//   delay(2000);

//   ei_printf("Recording...\n");

//   ool m = microphone_inference_record();
//   if (!m) {
//     ei_printf("ERR: Failed to record audio...\n");
//     return;
//   }

//   ei_printf("Recording done\n");

//   myLEDstripMIC.neoPixelFill(0, 50, 0, true);

//   signal_t signal;
//   signal.total_length = EI_CLASSIFIER_RAW_SAMPLE_COUNT;
//   signal.get_data = &microphone_audio_signal_get_data;
//   ei_impulse_result_t result = { 0 };

//   EI_IMPULSE_ERROR res = run_classifier_continuous(&signal, &result, debug_nn);
//   if (res != EI_IMPULSE_OK) {
//     ei_printf("ERR: Failed to run classifier (%d)\n", res);
//     return;
//   }

//   // print inference return code
//   ei_printf("run_classifier returned: %d\r\n", res);
//   print_inference_result(result);

//   if(flgKeyDetectedRed) {redColor = 255; greenColor = 0; blueColor = 0; myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true); flgKeyDetectedRed=0}
//   else if(flgKeyDetectedGreen) {redColor = 0; greenColor = 255; blueColor = 0; myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true); flgKeyDetectedGreen=0}
//   else if(flgKeyDetectedBlue) {redColor = 0; greenColor = 0; blueColor = 255; myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true); flgKeyDetectedBlue=0}

//   if(flgRestartMicrophone){
//     if (microphone_inference_start(EI_CLASSIFIER_RAW_SAMPLE_COUNT) == false) {
//         ei_printf("ERR: Could not allocate audio buffer (size %d), this could be due to the window length of your model\r\n", EI_CLASSIFIER_RAW_SAMPLE_COUNT);
//         return;
//     }
//     flgRestartMicrophone = 0;
//   }
// }



void myArduinoIotCloudInitHandler(void) {
  // Defined in thingProperties.h
  initProperties();
  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection, false);

  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}


//색깔 cloud로 보내기
void sendHSV_ColorDataToCloud(void) {
  rgb_to_hsv(redColor, greenColor, blueColor);

  setRGBColor.setHue(hue);
  setRGBColor.setSaturation(saturation);
  setRGBColor.setBrightness(value);
}

void rgb_to_hsv(double r, double g, double b) {
  r = r / 255.0;
  g = g / 255.0;
  b = b / 255.0;

  double cmax = max(r, max(g, b));
  double cmin = min(r, min(g, b));
  double diff = cmax - cmin;
  hue = -1;
  saturation = -1;

  if (cmax == cmin) hue = 0;
  else if (cmax == r)
    hue = fmod(60 * ((g - b) / diff) + 360, 360);
  else if (cmax == g)
    hue = fmod(60 * ((b - r) / diff) + 120, 360);
  else if (cmax == b)
    hue = fmod(60 * ((r - g) / diff) + 240, 360);

  if (cmax == 0) saturation = 0;
  else saturation = (diff / cmax) * 100;

  value = cmax * 100;
}
/*
  Since GetIMUAx is READ_WRITE variable, onGetIMUAxChange() is
  executed every time a new value is received from IoT Cloud.
*/

//ble
void bleConnectHandler(BLEDevice central) {
#if (DEBUG_MODE_ENABLE)
  Serial.print("Connected event, central: ");
  Serial.println(central.address());
#endif

  redColor = 0, greenColor = 0, blueColor = 200;
  myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true);

  ble_connected = true;
}


void bleDisconnectHandler(BLEDevice central) {
#if (DEBUG_MODE_ENABLE)
  Serial.print("Disconnected event, central: ");
  Serial.println(central.address());
#endif
  redColor = 0, greenColor = 0, blueColor = 0;
  myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true);

  setIoT_Mode = IoTMODE_CHANGE_DEACTIVATE_BLE;

  ble_connected = false;
}


void writtenEventCharacteristic(BLEDevice central, BLECharacteristic characteristic) {
  uint8_t value[32];
  int length;

  strMsgPacket = "";
  strMsgPacket.trim();

  length = myCharacteristic.valueLength();
  myCharacteristic.readValue((void *)value, length);


  for (int i = 0; i < length; i++) { strMsgPacket += (char)value[i]; }
#if (DEBUG_MODE_ENABLE)
  Serial.print("Length: ");
  Serial.print(length);
  Serial.print("Data: ");
  Serial.println(strMsgPacket);
#endif

  myPacketParseHandler(strMsgPacket);
}



void myPacketParseHandler(String rawPacketData) {
  cmdMode = rawPacketData.substring(0, 2).toInt();
  redColor = rawPacketData.substring(2, 5).toInt();
  greenColor = rawPacketData.substring(5, 8).toInt();
  blueColor = rawPacketData.substring(8, 11).toInt();

#if (DEBUG_MODE_ENABLE)
  Serial.print("Mode Value: ");
  Serial.println(cmdMode);
  Serial.print("Red Value: ");
  Serial.println(redColor);
  Serial.print("Green Value: ");
  Serial.println(greenColor);
  Serial.print("Blue Value: ");
  Serial.println(blueColor);
#endif
  switch (cmdMode) {
    case 0: break;
    case 2:
      // LED 켜짐, 꺼짐, red, green, blue
      myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true);
      flgModeDynamicEffectA = 0;
      flgModeDynamicEffectB = 0;
      break;
    case 4:
      // 레인보우 effect

      flgModeDynamicEffectA = 1;
      flgModeDynamicEffectB = 0;

      break;
    case 6:
      // fade effect
      ;
      flgModeDynamicEffectA = 0;
      flgModeDynamicEffectB = 1;

      break;
    default: break;
  }
  cmdMode = 0;
}

void onSetRGBColorChange() {
  // Add your code here to act upon SetRGBColor change
  if (setRGBColor.getSwitch()) {
#if (DEBUG_MODE_ENABLE)
    Serial.println("Lamp On");
#endif
    if ((setIoT_Mode == IoTMODE_WIFI) && !flgAutoBrightnessMode) {
      if (!myCloudSwitchStatus) {
        redColor = 255;
        greenColor = 255;
        blueColor = 255;
        sendHSV_ColorDataToCloud();
        myCloudSwitchStatus = 1;
      } else {
        setRGBColor.getValue().getRGB(redColor, greenColor, blueColor);
      }
    }


  } else {
#if (DEBUG_MODE_ENABLE)
    Serial.println("Lamp Off");
#endif
    redColor = 0;
    greenColor = 0;
    blueColor = 0;
    sendHSV_ColorDataToCloud();
    myCloudSwitchStatus = 0;
  }
  myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true);
  flgModeDynamicEffectA = 0;
  intSetMode = 0;
}

void onIntSetModeChange(void) {
  Serial.print("Set Mode: ");
  Serial.println(intSetMode);
  switch (intSetMode) {
    // wifi모드
    case 0:
      flgEmotionalModeEnable = 0;
      flgModeDynamicEffectA = 0;
      flgModeDynamicEffectB = 0;
      flgAutoBrightnessMode = 0;
      flgMachineLearningKeyWordSpeechControlMode = 0;
      break;
      // ble모드
    case 1:
      setIoT_Mode = IoTMODE_CHANGE_ACTIVATE_BLE;
      intSetMode = 0;
      flgModeDynamicEffectA = 0;
      flgModeDynamicEffectB = 0;
      flgEmotionalModeEnable = 0;
      flgAutoBrightnessMode = 0;
      flgMachineLearningKeyWordSpeechControlMode = 0;
      break;
      // 온습도에 따른 조명
    case 2:
      flgEmotionalModeEnable = 1;
      flgModeDynamicEffectA = 0;
      flgModeDynamicEffectB = 0;
      flgAutoBrightnessMode = 0;
      flgMachineLearningKeyWordSpeechControlMode = 0;
      break;
      //자동조명
    case 3:
      flgAutoBrightnessMode = 1;
      flgModeDynamicEffectA = 0;
      flgModeDynamicEffectB = 0;
      flgEmotionalModeEnable = 0;
      flgMachineLearningKeyWordSpeechControlMode = 0;
      break;
      // 언어감지
    case 4:
      setIoT_Mode = AI_MODE_PREPARE;
      flgMachineLearningKeyWordSpeechControlMode = 1;
      flgModeDynamicEffectA = 0;
      flgModeDynamicEffectB = 0;
      flgEmotionalModeEnable = 0;
      flgAutoBrightnessMode = 0;
      break;
      // 이펙트1
    case 5:
      flgModeDynamicEffectA = 1;
      flgModeDynamicEffectB = 0;
      flgEmotionalModeEnable = 0;
      flgAutoBrightnessMode = 0;
      flgMachineLearningKeyWordSpeechControlMode = 0;
      break;
      // 이펙트2
    case 6:
      flgModeDynamicEffectB = 1;
      flgModeDynamicEffectA = 0;
      flgEmotionalModeEnable = 0;
      flgAutoBrightnessMode = 0;
      flgMachineLearningKeyWordSpeechControlMode = 0;
      break;
      // off
    case 7:
      redColor = 0;
      greenColor = 0;
      blueColor = 0;
      myCommonCodeRunFunction();
      setRGBColor.setSwitch(0);
      break;
      // on
    case 8:
      redColor = 255;
      greenColor = 255;
      blueColor = 255;
      myCommonCodeRunFunction();
      break;

      //red, green, blue
    case 9:
      redColor = 255;
      greenColor = 0;
      blueColor = 0;
      myCommonCodeRunFunction();
      break;
    case 10:
      redColor = 0;
      greenColor = 255;
      blueColor = 0;
      myCommonCodeRunFunction();
      break;
    case 11:
      redColor = 0;
      greenColor = 0;
      blueColor = 255;
      myCommonCodeRunFunction();
      break;

    default: break;
  }
}
void myCommonCodeRunFunction(void) {
  flgEmotionalModeEnable = 0;
  flgModeDynamicEffectA = 0;
  flgModeDynamicEffectB = 0;
  flgAutoBrightnessMode = 0;
  flgMachineLearningKeyWordSpeechControlMode = 0;
  myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true);
  sendHSV_ColorDataToCloud();
}

void appLedStripControlHandler(void) {
  if ((unsigned)(millis() - dynamicLedCtrlPreviousMillis) >= dynamicLedCtrlInterval) {
    // rainboweffect
    if (flgModeDynamicEffectA) {
      myRainbowEffect();
      sendHSV_ColorDataToCloud();
    }
    // RainbowCycleEffect
    // else if (flgModeDynamicEffectB) {
    //   myRainbowCycleEffect();
    //   sendHSV_ColorDataCloud();
    // }
    else if (flgModeDynamicEffectB) {
      myColorWipeEffect(255, 0, 0);
      myColorWipeEffect(0, 255, 0);
      myColorWipeEffect(0, 0, 255);
      sendHSV_ColorDataToCloud();
    }

    dynamicLedCtrlPreviousMillis = millis();




    // fade effect
    // else if (flgModeEffectB) {
    //   redColor = 150;
    //   greenColor = 150;
    //   blueColor = 150;
    //   valueSetBrightness = 150;
    //   while (redColor >= 0 && greenColor >= 0 && blueColor >= 0) {
    //     if ((unsigned long)(millis() - rainbowPreviousMillis) >= pixelsInterval) {
    //       rainbowPreviousMillis = millis();
    //       myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true);
    //       redColor -= 10;
    //       greenColor -= 10;
    //       blueColor -= 10;
    //       Serial.println(redColor);
    //     }
    //   }
    //   // colorValueSender();
    //   flgModeEffectB = 0;
    // }
  }
}



void myRainbowEffect() {
  for (uint16_t i = 0; i < NUM_NEOPIXELS; i++) {
    Wheel((i + rainbowCycles) & 255);
    myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true);
  }

  rainbowCycles++;

  if (rainbowCycles >= 256) rainbowCycles = 0;
}


void myRainbowCycleEffect() {
  uint16_t i;

  for (i = 0; i < NUM_NEOPIXELS; i++) {
    Wheel(((i * 256 / NUM_NEOPIXELS) + rainbowCycleCycles) & 255);
    myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true);
  }

  rainbowCycleCycles++;

  if (rainbowCycleCycles >= 256) rainbowCycleCycles = 0;
}

void myColorWipeEffect(uint8_t r, uint8_t g, uint8_t b) {
  switch (seqColorWipeHandlerFlowCtrl) {
    case 0:
      numPixel = 0;
      seqColorWipeHandlerFlowCtrl++;
      break;
    case 1:
      myLEDstrip.neoPixelSetValue(numPixel, r, g, b, true);
      redColor *r, greenColor *g, blueColor *b;
      sendHSV_ColorDataToCloud();
      seqColorWipeHandlerFlowCtrl++;
      break;
    case 2:
      numPixel++;
      seqColorWipeHandlerFlowCtrl++;
      break;
    case 3:
      if (numPixel > NUM_NEOPIXELS) seqColorWipeHandlerFlowCtrl = 0;
      else seqColorWipeHandlerFlowCtrl = 1;
      break;
    case 4:
      seqColorWipeHandlerFlowCtrl = 0;
      break;
    default: break;
  }
}



uint32_t Wheel(byte WheelPos) {
  WheelPos = 255 - WheelPos;

  if (WheelPos < 85) {
    redColor = 255 - WheelPos * 3;
    greenColor = 0;
    blueColor = WheelPos * 3;
    return 1;
  }

  if (WheelPos < 170) {
    WheelPos -= 85;
    redColor = 0;
    greenColor = WheelPos * 3;
    blueColor = 255 - WheelPos * 3;
    return 1;
  }

  WheelPos -= 170;

  redColor = WheelPos * 3;
  greenColor = 255 - WheelPos * 3;
  blueColor = 0;

  return 1;
}

bool mySensorDataAcquisitionFunction(void *) {
  myDHT_SensorDAQ();
  myLightSensorDAQ();
  return 1;
}

// 온습도센서
void myDHT_SensorDAQ(void) {
  float h = myDHT.readHumidity();
  float t = myDHT.readTemperature();
  unsigned char getTempData;

#if (DEBUG_MODE_ENABLE)
  Serial.print(F("H: "));
  Serial.print(h);
  Serial.print(F("[%]"));
  Serial.println();
  Serial.print(F("T: "));
  Serial.print(t);
  Serial.print(F("[°C]"));
  Serial.println();
#endif
  if (setIoT_Mode == IoTMODE_WIFI) {
    fHumidity = h;
    fTemperature = t;
    if (flgEmotionalModeEnable) {
      getTempData = t + h / 100;
      if (h > 70) getTempData += 5;

#if (DEBUG_MODE_ENABLE)
      Serial.print("getTempData: ");
      Serial.print(getTempData);
      Serial.println(F("° C "));
#endif

      if (getTempData < 24) {
        redColor = 255;
        greenColor = 89;
        blueColor = 89;
      } else if (getTempData < 25) {
        redColor = 254;
        greenColor = 155;
        blueColor = 120;
      } else if (getTempData < 26) {
        redColor = 255;
        greenColor = 255;
        blueColor = 255;
      } else if (getTempData < 27) {
        redColor = 58;
        greenColor = 199;
        blueColor = 131;
      } else {
        redColor = 0;
        greenColor = 0;
        blueColor = 250;
      }
      myLEDstrip.neoPixelFill(redColor, greenColor, blueColor, true);
      sendHSV_ColorDataToCloud();
    }
  }
}


// 조도센서
void myLightSensorDAQ(void) {
  unsigned char getBrightness;
  float lux = lightMeter.readLightLevel();
  Serial.print("Light: ");
  Serial.print(lux);
  Serial.println("[lx]");
  if (setIoT_Mode == IoTMODE_WIFI)
    fLightBrightness = lux;
  if (flgAutoBrightnessMode) {
    getBrightness = map(lux, 0, 10000, 0, 255);
    if (getBrightness > 10000)
      getBrightness = 10000;
    myLEDstrip.neoPixelFill(redColor * ((float)getBrightness / 255), greenColor * ((float)getBrightness / 255), blueColor * ((float)getBrightness / 255), true);
    setRGBColor.setBrightness(map(getBrightness, 0, 255, 0, 100));
#if (DEBUG_MODE_ENABLE)
    Serial.print("Brightness: ");
    Serial.println(getBrightness);
#endif
  }
}

// static void pdm_data_ready_inference_callback(void)
// {
//     int bytesAvailable = PDM.available();

//     // read into the sample buffer
//     int bytesRead = PDM.read((char *)&sampleBuffer[0], bytesAvailable);

//     if ((inference.buf_ready == 0) && (record_ready == true)) {

//         for(int i = 0; i < bytesRead>>1; i++) {
//             inference.buffer[inference.buf_count++] = sampleBuffer[i];

//             if(inference.buf_count >= inference.n_samples) {
//                 inference.buf_count = 0;
//                 inference.buf_ready = 1;
//                 break;
//             }
//         }
//     }
// }

// static bool microphone_inference_start(uint32_t n_samples)
// {
//     inference.buffer = (int16_t *)malloc(n_samples * sizeof(int16_t));

//     if(inference.buffer == NULL) {
//         return false;
//     }

//     inference.buf_count  = 0;
//     inference.n_samples  = n_samples;
//     inference.buf_ready  = 0;

//     // configure the data receive callback
//     PDM.onReceive(pdm_data_ready_inference_callback);

//     PDM.setBufferSize(2048);
//     delay(250);

//     // initialize PDM with:
//     // - one channel (mono mode)
//     if (!PDM.begin(1, EI_CLASSIFIER_FREQUENCY)) {
//         ei_printf("ERR: Failed to start PDM!");
//         microphone_inference_end();
//         return false;
//     }

//     // optionally set the gain, defaults to 24
//     // Note: values >=52 not supported
//     //PDM.setGain(40);

//     return true;
// }

// static bool microphone_inference_record(void)
// {
//     bool ret = true;

//     record_ready = true;
//     while (inference.buf_ready == 0) {
//         delay(10);
//     }

//     inference.buf_ready = 0;
//     record_ready = false;

//     return ret;
// }

// static int microphone_audio_signal_get_data(size_t offset, size_t length, float *out_ptr)
// {
//     numpy::int16_to_float(&inference.buffer[offset], out_ptr, length);

//     return 0;
// }

// void print_inference_result(ei_impulse_result_t result) {

//     // Print how long it took to perform inference
//     ei_printf("Timing: DSP %d ms, inference %d ms, anomaly %d ms\r\n",
//             result.timing.dsp,
//             result.timing.classification,
//             result.timing.anomaly);

//     ei_printf("Predictions:\r\n");
//     for (uint16_t i = 0; i < EI_CLASSIFIER_LABEL_COUNT; i++) {
//         ei_printf("  %s: ", ei_classifier_inferencing_categories[i]);
//         ei_printf("%.5f\r\n", result.classification[i].value);

//         ////////////////////////////////////////
//         //Lable 0 ==> Blue: 0.00000
//         //Lable 1 ==> Green: 0.00000
//         //Lable 2 ==> Noise: 0.99609
//         //Lable 3 ==> Off: 0.00000
//         //Lable 4 ==> On: 0.00391
//         //Lable 5 ==> Red: 0.00000
//         ////////////////////////////////////////
//         if(result.classification[0].value > 0.8) {flgKeyDetectedBlue=1;}
//         else if(result.classification[1].value > 0.8) {flgKeyDetectedGreen=1;}
//         //else if(result.classification[2].value > 0.8) { digitalWrite(LEDR, LOW); digitalWrite(LEDG, LOW); digitalWrite(LEDB, LOW);}
//         else if(result.classification[3].value > 0.8) {setIoT_Mode = AI_MODE_END_PROCESS; myLEDstripMIC.neoPixelFill(0, 0, 0, true); sendHSV_ColorDataToCloud();}
//         else if(result.classification[4].value > 0.8) {myLEDstripMIC.neoPixelFill(200, 200, 200, true); sendHSV_ColorDataToCloud();}
//         else if(result.classification[5].value > 0.8) {flgKeyDetectedRed=1;}

//     }

//     // Print anomaly result (if it exists)
// #if EI_CLASSIFIER_HAS_ANOMALY == 1
//     ei_printf("Anomaly prediction: %.3f\r\n", result.anomaly);
// #endif

// }

// static void microphone_inference_end(void)
// {
//     PDM.end();
//     ei_free(inference.buffer);
// }

// #if !defined(EI_CLASSIFIER_SENSOR) || EI_CLASSIFIER_SENSOR != EI_CLASSIFIER_SENSOR_MICROPHONE
// #error "Invalid model for current sensor."
// #endif


void onFHumidityChange() {
}
void onFLightBrightnessChange() {
}
void onFTemperatureChange() {
}